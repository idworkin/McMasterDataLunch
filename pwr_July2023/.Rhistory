knit_with_parameters("~/Dropbox/repos/McMasterDataLunch/pwr_July2023/PowerAnalysisDataLunch_2023.Rmd")
N = 1000  # Number of simulations for inner loop. You generally want this to be >1000.
p = rep(NA, N) # initializing the vector to store the p values in the inner for loop.
#Global Parameter values
a = 0.5 # intercept
b <- seq(from = 0, to = 1.0,by = 0.1) # slopes to try
sample_size <- seq(from = 5, to = 50, by = 1)  # Incremently increasing sample size from 10 to 100 by 10 observations at a time.
power.size <- numeric(length(sample_size)) # initializing the vector to store the power at each sample size for the outer for loop.
### initialize the matrix to store all of the power estimates
power.b <- matrix(NA, length(sample_size), length(b))
## Now the actual for loop
for (k in 1:length(b))  # across the different effect sizes
{
b_b <- b[k]
for (j in 1:length(sample_size))  # looping through the different sample_sizes
{
s_s = sample_size[j]
for (i in 1:N)
{
x <- rnorm(s_s, mean=8, sd=2)  # simulate values of predictor
y_det <- a + b_b*x             # deterministic part of model
y_sim <- rnorm(s_s, mean=y_det,sd=2)  # Simulate y|x values
lm1 <- lm(y_sim~x)                    # fit model given simulation
p[i] <- coef(summary(lm1))[2,4] # You may want to extract a different p-value from the model.
}
power.size[j] <- length(p[p<0.05])/N   # How many p-values are less than alpha (0.05)
}
power.b[,k] <- power.size
}
pwr_anova_SS <- power.anova.test(groups = 4, # how many groups
between.var = 1, # between group variance
within.var = 3, # within group variance
sig.level = 0.05, # alpha
power = .80)
pwr_anova_SS
4*12
pwr_anova_SS <- power.anova.test(groups = 6, # how many groups
between.var = 1, # between group variance
within.var = 3, # within group variance
sig.level = 0.05, # alpha
power = .80)
<- power.anova.test(groups = 6, # how many groups
pwr_anova_SS
6*9
par(mfrow = c(1,1))
filled.contour(z = power.b, x = sample_size, y = b,
ylim = c(min(b), max(b)), xlim = c(min(sample_size), max(sample_size)),
xlab = "Sample Size", ylab = "slope", color = topo.colors,
key.title = title(main = "power"))
q()
precision_wanted <- seq(from = 0.05, to = 0.5, by = 0.01)
sample_size_needed <- (1/precision_wanted)^2
plot(y = sample_size_needed, x = precision_wanted,
type = "p", pch = 21, col = "purple"  )
precision_wanted <- seq(from = 0.05, to = 0.5, by = 0.01)
sample_size_needed <- (1/precision_wanted)^2
plot(y = sample_size_needed, x = precision_wanted,
type = "p", pch = 20, col = "purple"  )
precision_wanted <- seq(from = 0.05, to = 0.5, by = 0.01)
sample_size_needed <- (1/precision_wanted)^2
plot(y = sample_size_needed, x = precision_wanted,
type = "p", pch = 20, col = "purple",
xlab = "precision desired",
ylab = "sample size needed")
?plot
precision_wanted <- seq(from = 0.05, to = 0.5, by = 0.01)
sample_size_needed <- (1/precision_wanted)^2
plot(y = sample_size_needed, x = precision_wanted,
type = "p", pch = 20, col = "purple",
log = "y",
xlab = "precision desired",
ylab = "sample size needed")
qnorm(0.95)
qnorm(0.975, lower)
qnorm(0.975)
qt(0.95, df = 50)
qt(0.95, df = 35)
qnorm(0.975) # two sided
qnorm(0.95) # one sided
qt(0.95, df = 35)
qt(0.95, df = 50)
qnorm(0.8)
multipler_we_need <- qnorm(0.8) + qnorm(0.95)
multipler_we_need
multipler_we_need <- qnorm(0.8) + qnorm(0.975)
multipler_we_need
